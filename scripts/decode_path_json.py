#!/usr/bin/env python3
"""
Decode and visualize JSON files generated by generate_path_jsons.py

This script reads the compressed JSON format and displays the transaction
using the existing visualization functions from fee_simulator.display.
"""

import json
import argparse
import os
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Any
from collections import defaultdict

# Add parent directory to path to enable imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from fee_simulator.models import TransactionBudget, TransactionRoundResults, Round, Rotation, Appeal
from fee_simulator.types import Vote, RoundLabel
from fee_simulator.core.transaction_processing import process_transaction
from fee_simulator.core.round_labeling import label_rounds
from fee_simulator.display import (
    display_transaction_results,
    display_fee_distribution,
    display_summary_table,
    display_test_description,
)
from tests.round_combinations.graph_data import TRANSACTION_GRAPH
from fee_simulator.core.path_to_transaction import path_to_transaction_results
from fee_simulator.utils import generate_random_eth_address


def load_lookup_tables(json_dir: Path) -> Dict[str, Dict]:
    """Load the lookup tables from the JSON directory."""
    lookup_file = json_dir / "lookup_tables.json"
    with open(lookup_file, 'r') as f:
        return json.load(f)


def decode_path(compressed_data: Dict, lookup_tables: Dict) -> Tuple[List[str], List[RoundLabel]]:
    """Decode the compressed path and labels using lookup tables."""
    # Decode path
    path = []
    for idx in compressed_data["path"]:
        path.append(lookup_tables["node_map"][str(idx)])
    
    # Decode labels
    labels = []
    for idx in compressed_data["labels"]:
        if idx >= 0:
            labels.append(lookup_tables["label_map"][str(idx)])
    
    return path, labels


def decode_roles(role_indices: List[List[int]], lookup_tables: Dict) -> List[Tuple[int, str]]:
    """Decode role indices to (round_index, role) tuples."""
    roles = []
    for round_idx, role_idx in role_indices:
        role = lookup_tables["role_map"][str(role_idx)]
        roles.append((round_idx, role))
    return roles


def decode_invariants(bitfield: int, lookup_tables: Dict) -> Dict[str, bool]:
    """Decode invariant bitfield to dictionary of invariant name -> pass/fail."""
    invariants = {}
    invariant_bits = lookup_tables["invariant_bits"]
    
    for bit_str, name in invariant_bits.items():
        bit_pos = int(bit_str)
        passed = bool(bitfield & (1 << bit_pos))
        invariants[name] = passed
    
    return invariants


def reconstruct_transaction(compressed_data: Dict, lookup_tables: Dict, addresses: List[str]) -> Tuple[TransactionRoundResults, TransactionBudget]:
    """Reconstruct the full transaction from compressed data."""
    # Decode path
    path, labels = decode_path(compressed_data, lookup_tables)
    
    # Get sender and appealant addresses
    # In the compression, addresses are numbered starting from 1
    # Find the highest numbered addresses which should be sender and appealant
    max_addr_idx = max(int(k) for k in compressed_data["participants"].keys())
    sender_idx = max_addr_idx
    appealant_idx = max_addr_idx - 1
    
    # Map compressed indices to actual addresses
    addr_map = {}
    for idx_str in compressed_data["participants"].keys():
        idx = int(idx_str)
        if idx <= len(addresses):
            addr_map[idx] = addresses[idx - 1]  # 1-indexed to 0-indexed
        else:
            # Generate additional addresses if needed
            addr_map[idx] = generate_random_eth_address()
    
    sender_address = addr_map[sender_idx]
    appealant_address = addr_map[appealant_idx]
    
    # Use path_to_transaction_results to recreate the transaction
    # We need the full address list with correct mapping
    full_addresses = []
    for i in range(max(addr_map.keys())):
        if i + 1 in addr_map:
            full_addresses.append(addr_map[i + 1])
        else:
            full_addresses.append(generate_random_eth_address())
    
    transaction_results, transaction_budget = path_to_transaction_results(
        path=path,
        addresses=full_addresses,
        sender_address=sender_address,
        appealant_address=appealant_address,
        leader_timeout=100,  # Default values
        validators_timeout=200,
    )
    
    return transaction_results, transaction_budget, full_addresses


def display_compressed_data(compressed_data: Dict, lookup_tables: Dict):
    """Display the compressed data in a readable format."""
    print("\n" + "=" * 80)
    print("COMPRESSED DATA SUMMARY")
    print("=" * 80)
    
    # Decode and display path
    path, labels = decode_path(compressed_data, lookup_tables)
    print(f"\nPath: {' -> '.join(path)}")
    print(f"Path Length: {len(path) - 2} (excluding START/END)")
    
    # Display labels
    print(f"\nRound Labels: {labels}")
    
    # Display hash
    print(f"\nPath Hash: {compressed_data['hash']}")
    
    # Decode and display invariants
    invariants = decode_invariants(compressed_data['invariants'], lookup_tables)
    passed = sum(1 for v in invariants.values() if v)
    total = len(invariants)
    print(f"\nInvariants: {passed}/{total} passed")
    
    if passed < total:
        print("\nFailed invariants:")
        for name, passed in invariants.items():
            if not passed:
                print(f"  - {name}")
    
    # Display participant summary
    print(f"\nActive Participants: {len(compressed_data['participants'])}")
    print("\nParticipant Summary:")
    print(f"{'Addr':>6} {'Rounds':>10} {'Cost':>10} {'Earned':>10} {'Slashed':>10} {'Burned':>10}")
    print("-" * 66)
    
    for addr_idx, data in sorted(compressed_data['participants'].items(), key=lambda x: int(x[0])):
        rounds = len(data['r'])
        print(f"{addr_idx:>6} {rounds:>10} {data['c']:>10} {data['e']:>10} {data['s']:>10} {data['b']:>10}")
    
    # Calculate totals
    total_cost = sum(p['c'] for p in compressed_data['participants'].values())
    total_earned = sum(p['e'] for p in compressed_data['participants'].values())
    total_slashed = sum(p['s'] for p in compressed_data['participants'].values())
    total_burned = sum(p['b'] for p in compressed_data['participants'].values())
    
    print("-" * 66)
    print(f"{'TOTAL':>6} {'':>10} {total_cost:>10} {total_earned:>10} {total_slashed:>10} {total_burned:>10}")


def main():
    parser = argparse.ArgumentParser(
        description="Decode and visualize path JSON files",
        epilog="Examples:\n"
               "  python decode_path_json.py path_jsons/length_03/02-0cd0354f.json\n"
               "  python decode_path_json.py path_jsons/length_03/02-0cd0354f.json --show-all\n"
               "  python decode_path_json.py path_jsons/length_03/02-0cd0354f.json --show-transaction --show-fees",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "json_file",
        type=str,
        help="Path to the JSON file to decode"
    )
    parser.add_argument(
        "--json-dir",
        type=str,
        default="path_jsons",
        help="Directory containing the JSON files and lookup tables (default: path_jsons)"
    )
    parser.add_argument(
        "-c", "--show-compressed",
        action="store_true",
        help="Show the compressed data summary (default if no options specified)"
    )
    parser.add_argument(
        "-t", "--show-transaction",
        action="store_true",
        help="Show the full transaction results"
    )
    parser.add_argument(
        "-f", "--show-fees",
        action="store_true",
        help="Show the detailed fee distribution"
    )
    parser.add_argument(
        "-s", "--show-summary",
        action="store_true",
        help="Show the summary table (default if no options specified)"
    )
    parser.add_argument(
        "-a", "--show-all",
        action="store_true",
        help="Show all visualizations"
    )
    
    args = parser.parse_args()
    
    # If no specific visualization is requested, default to showing compressed and summary
    if not any([args.show_compressed, args.show_transaction, args.show_fees, args.show_summary, args.show_all]):
        args.show_compressed = True
        args.show_summary = True
    
    # Load the JSON file
    with open(args.json_file, 'r') as f:
        compressed_data = json.load(f)
    
    # Load lookup tables
    json_dir = Path(args.json_dir)
    lookup_tables = load_lookup_tables(json_dir)
    
    # Decode path for display
    path, _ = decode_path(compressed_data, lookup_tables)
    test_description = f"Decoded transaction path: {' -> '.join(path)}"
    display_test_description("Path Visualization", test_description)
    
    # Show compressed data if requested
    if args.show_compressed or args.show_all:
        display_compressed_data(compressed_data, lookup_tables)
    
    # Reconstruct transaction if needed for other visualizations
    if args.show_transaction or args.show_fees or args.show_summary or args.show_all:
        # Generate addresses
        addresses = [generate_random_eth_address() for _ in range(1000)]
        
        # Reconstruct transaction
        transaction_results, transaction_budget, full_addresses = reconstruct_transaction(
            compressed_data, lookup_tables, addresses
        )
        
        # Get round labels
        round_labels = label_rounds(transaction_results)
        
        # Process transaction to get fee events
        fee_events, _ = process_transaction(
            addresses=full_addresses,
            transaction_results=transaction_results,
            transaction_budget=transaction_budget,
        )
        
        # Show transaction results
        if args.show_transaction or args.show_all:
            print("\n" + "=" * 80)
            print("TRANSACTION RESULTS")
            print("=" * 80)
            display_transaction_results(transaction_results, round_labels)
        
        # Show fee distribution
        if args.show_fees or args.show_all:
            print("\n" + "=" * 80)
            print("FEE DISTRIBUTION")
            print("=" * 80)
            display_fee_distribution(fee_events)
        
        # Show summary table
        if args.show_summary or args.show_all:
            print("\n" + "=" * 80)
            print("SUMMARY TABLE")
            print("=" * 80)
            display_summary_table(fee_events, transaction_results, transaction_budget, round_labels)


if __name__ == "__main__":
    main()